---
title: "Part 2: Getting Started with Neun"
subtitle: "Introduction to the Neun Library"
format:
  html:
    toc: true
    toc-depth: 3
    code-fold: show
---

## Introduction to Neun

[Neun](https://github.com/GNB-UAM/Neun/) is a high-performance C++ library for simulating dynamical systems, aimed at modeling neural networks.

The `neun_py` package provides Python bindings to use Neun, giving users access to Neun's efficient C++ implementation in Python.

### Why Neun?

- **High performance**: C++ core with optimized numerical integrators
- **Type safe**: Automatic enum generation for variables and parameters
- **Flexible**: Multiple neuron models (Hodgkin-Huxley, Hindmarsh-Rose, Izhikevich, etc.)
- **Multiple integrators**: RungeKutta4, RungeKutta6, Euler, and Stepper
- **Precision options**: Both float and double precision support
- **Header-Only C++ library**: Easy integration in C++ projects

## Installation and Setup

### Installing Neun

First, ensure you have Python 3.8+ and a C++ compiler with C++20 support (GCC 10+, Clang 10+). You'll need to install the Neun C++ library first, then build the Python bindings.

#### Installing the C++ Library

```bash
# Clone and build Neun
git clone https://github.com/GNB-UAM/Neun.git
cd Neun
mkdir build && cd build
cmake ..
make
sudo make install
```

#### Installing Python Bindings

```bash
# Clone and build neun_py
git clone https://github.com/GNB-UAM/neun_py.git
cd neun_py
make  # Generates code and installs in editable mode

# Or install with optional dependencies for examples
pip install neun_py[examples]  # Includes matplotlib and numpy
```

### Verifying Installation

Let's check that everything is installed correctly:

```python
import neun_py
import numpy as np
import matplotlib.pyplot as plt

# Check available neuron models
neurons = neun_py.get_available_neurons()
print(f"Available neuron types: {neurons}")

# Check available synapses
synapses = neun_py.get_available_synapses()
print(f"Available synapse types: {synapses}")

print("\nNeun Python bindings loaded successfully!")
```

::: {.callout-tip}
## Using Virtual Environments

It's recommended to use a virtual environment for the workshop:

```bash
python -m venv neun-workshop
source neun-workshop/bin/activate  # On Windows: neun-workshop\Scripts\activate
pip install -r requirements.txt
```
:::

## Neun Architecture Overview

Neun is organized around several key concepts:

### 1. Neurons

Individual computational units that integrate inputs and generate outputs. Neun provides several biophysically-based neuron models.

**Available neuron models**:

| Model | Short Name | Description |
|-------|------------|-------------|
| **Hodgkin-Huxley** | `HH` | Classic conductance-based model |
| **Hindmarsh-Rose** | `HR` | Simplified bursting model |
| **Izhikevich**     |      | Izhikevich spiking neuron model (2003) |
| **Matsuoka**       |      | Matsuoka oscillator (1985) |
| **RowatSelverston**|      | Rowat and Selverston model (1997) |
| **Rulkov**         |      | Rulkov Map model (2002) |
| **Vavoulis**       |      | Vavoulis model (2007) |

**Naming convention**: Models are named as `{Model}{Precision}{Integrator}`
- Example: `HHDoubleRK4` = Hodgkin-Huxley, Double precision, RungeKutta4

### 2. Synapses

Connections between neurons that transmit signals.

**Available synapse types**:

- **Diffusion Synapse**: Based on Destexhe et al. 1994
- **Electrical Synapse** (`ESyn`): Gap junction coupling
- **Conductance-based Direct Synapse**: Synaptic conductance
- **Sigmoidal Direct Synapse**: Nonlinear transmission

**Naming convention**: `{SynapseType}{Neuron1}{Neuron2}{Precision}{Integrator}`
- Example: `ESynHHHHDoubleRK4` = Electrical synapse between two HH neurons

### 3. Integrators

Numerical methods for solving differential equations.

**Available integrators**:

- **RK4**: 4th-order Runge-Kutta (most common)
- **RK6**: 6th-order Runge-Kutta (higher accuracy)
- **Euler**: Simple Euler method
- **Stepper**: Basic stepping

### 4. Parameters and Variables

Neun uses type-safe enums for accessing neuron properties:

- **Parameters**: Model constants (e.g., conductances, capacitances)
  - Set using `neuron.set_param(enum, value)`
- **Variables**: Dynamic state (e.g., membrane potential, gating variables)
  - Set using `neuron.set_var(enum, value)` or `neuron.set(enum, value)`
  - Get using `neuron.get(enum)`

Example enums: `HHDoubleParameter.cm`, `HHDoubleVariable.v`

## Your First Neun Program

Let's create a simple Hodgkin-Huxley neuron simulation to understand the basic workflow:

```python
import neun_py
import numpy as np
import matplotlib.pyplot as plt

# Step 1: Create constructor arguments
args = neun_py.HHDoubleConstructorArgs()

# Step 2: Create a Hodgkin-Huxley neuron with Double precision and RK4 integrator
neuron = neun_py.HHDoubleRK4(args)

# Step 3: Set parameter values
neuron.set_param(neun_py.HHDoubleParameter.cm, 1.0 * 7.854e-3)    # Capacitance
neuron.set_param(neun_py.HHDoubleParameter.vna, 50.0)            # Na reversal
neuron.set_param(neun_py.HHDoubleParameter.vk, -77.0)            # K reversal  
neuron.set_param(neun_py.HHDoubleParameter.vl, -54.387)          # Leak reversal
neuron.set_param(neun_py.HHDoubleParameter.gna, 120 * 7.854e-3)  # Na conductance
neuron.set_param(neun_py.HHDoubleParameter.gk, 36 * 7.854e-3)    # K conductance
neuron.set_param(neun_py.HHDoubleParameter.gl, 0.3 * 7.854e-3)   # Leak conductance

# Step 4: Set initial conditions
neuron.set_var(neun_py.HHDoubleVariable.v, -80.0)  # Membrane potential
neuron.set_var(neun_py.HHDoubleVariable.m, 0.1)    # Na activation
neuron.set_var(neun_py.HHDoubleVariable.n, 0.7)    # K activation
neuron.set_var(neun_py.HHDoubleVariable.h, 0.01)   # Na inactivation

# Step 5: Run simulation
dt = 0.001            # Time step (ms)
T = 100               # Simulation duration (ms)
time = np.arange(0, T, dt)

V = []  # Membrane potential storage

for t in time:
    # Add external current input
    neuron.add_synaptic_input(0.1)  # Constant input current
    
    # Step neuron forward
    neuron.step(dt)
    
    # Record voltage
    V.append(neuron.get(neun_py.HHDoubleVariable.v))

# Step 6: Visualize
fig, ax = plt.subplots(figsize=(10, 6))

ax.plot(time, V, 'b-', linewidth=1.5)
ax.set_xlabel('Time (ms)')
ax.set_ylabel('Membrane Potential (mV)')
ax.set_title('Hodgkin-Huxley Neuron - Basic Simulation')
ax.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

print(f"Simulation completed: {len(time)} time steps")
print(f"Final voltage: {V[-1]:.2f} mV")
```

::: {.callout-note}
## Understanding the Workflow

The basic Neun workflow consists of:

1. **Create constructor args** for the neuron model
2. **Instantiate neuron** with model type, precision, and integrator
3. **Set parameters** using enums (e.g., `HHDoubleParameter.cm`)
4. **Set initial conditions** for variables
5. **Simulate** by stepping through time with `neuron.step(dt)`
6. **Add inputs** with `neuron.add_synaptic_input(current)`
7. **Read state** using `neuron.get(variable_enum)`
:::

## Exploring Neuron Models

### Hodgkin-Huxley (HH)

The classic biophysical neuron model with sodium and potassium conductances:

```python
import neun_py
import numpy as np
import matplotlib.pyplot as plt

# Compare different external currents
currents = [0.05, 0.1, 0.15]
colors = ['blue', 'green', 'red']

fig, axes = plt.subplots(len(currents), 1, figsize=(10, 8), sharex=True)

dt = 0.001
T = 100
time = np.arange(0, T, dt)

for idx, (I_ext, color) in enumerate(zip(currents, colors)):
    # Create neuron
    args = neun_py.HHDoubleConstructorArgs()
    neuron = neun_py.HHDoubleRK4(args)
    
    # Set parameters
    neuron.set_param(neun_py.HHDoubleParameter.cm, 1.0 * 7.854e-3)
    neuron.set_param(neun_py.HHDoubleParameter.vna, 50.0)
    neuron.set_param(neun_py.HHDoubleParameter.vk, -77.0)
    neuron.set_param(neun_py.HHDoubleParameter.vl, -54.387)
    neuron.set_param(neun_py.HHDoubleParameter.gna, 120 * 7.854e-3)
    neuron.set_param(neun_py.HHDoubleParameter.gk, 36 * 7.854e-3)
    neuron.set_param(neun_py.HHDoubleParameter.gl, 0.3 * 7.854e-3)
    
    # Set initial conditions
    neuron.set_var(neun_py.HHDoubleVariable.v, -80.0)
    neuron.set_var(neun_py.HHDoubleVariable.m, 0.1)
    neuron.set_var(neun_py.HHDoubleVariable.n, 0.7)
    neuron.set_var(neun_py.HHDoubleVariable.h, 0.01)
    
    # Simulate
    V = []
    for t in time:
        neuron.add_synaptic_input(I_ext)
        neuron.step(dt)
        V.append(neuron.get(neun_py.HHDoubleVariable.v))
    
    # Plot
    axes[idx].plot(time, V, color=color, linewidth=1.5)
    axes[idx].set_ylabel('V (mV)')
    axes[idx].set_title(f'External Current = {I_ext} nA')
    axes[idx].grid(True, alpha=0.3)

axes[-1].set_xlabel('Time (ms)')
plt.suptitle('Effect of Input Current on Hodgkin-Huxley Neuron', y=1.02)
plt.tight_layout()
plt.show()
```

**Observation**: Higher external current leads to:
- More frequent action potentials
- Higher firing rate
- Different spiking patterns

### Hindmarsh-Rose (HR)

A reduced model that can produce bursting and chaotic behavior:

```python
import neun_py
import numpy as np
import matplotlib.pyplot as plt

# Different parameter sets for HR neuron
parameter_sets = [
    {'name': 'Regular Spiking', 'I': 3.0},
    {'name': 'Bursting', 'I': 3.5},
    {'name': 'Chaotic', 'I': 3.8},
]

fig, axes = plt.subplots(len(parameter_sets), 1, figsize=(12, 8))

dt = 0.01
T = 500
time = np.arange(0, T, dt)

for idx, params in enumerate(parameter_sets):
    # Create Hindmarsh-Rose neuron
    args = neun_py.HRDoubleConstructorArgs()
    neuron = neun_py.HRDoubleRK4(args)
    
    # HR model uses default parameters, but we can modify them if needed
    # Set initial conditions
    neuron.set_var(neun_py.HRDoubleVariable.x, -1.0)
    neuron.set_var(neun_py.HRDoubleVariable.y, -5.0)
    neuron.set_var(neun_py.HRDoubleVariable.z, 0.0)
    
    # Simulate with different input currents
    V = []
    for t in time:
        neuron.add_synaptic_input(params['I'])
        neuron.step(dt)
        V.append(neuron.get(neun_py.HRDoubleVariable.x))  # x is membrane potential
    
    # Plot
    axes[idx].plot(time, V, 'b-', linewidth=1)
    axes[idx].set_title(f"{params['name']} (I = {params['I']})")
    axes[idx].set_ylabel('Membrane Potential')
    axes[idx].grid(True, alpha=0.3)
    if idx == len(parameter_sets) - 1:
        axes[idx].set_xlabel('Time (ms)')

plt.suptitle('Hindmarsh-Rose Neuron: Different Firing Patterns', fontsize=14)
plt.tight_layout()
plt.show()
```

::: {.callout-important}
## Choosing a Neuron Model

- **HH (Hodgkin-Huxley)**: Biophysically detailed, captures ion channel dynamics
- **HR (Hindmarsh-Rose)**: Bursting and chaotic behavior, moderate complexity
- **Izhikevich**: Various firing patterns with simple equations
- **Matsuoka**: Central pattern generator, oscillatory networks
- **Rulkov**: Map-based model, computationally efficient

**Integrator Selection**:
- **RK4**: Best balance of accuracy and speed (recommended)
- **RK6**: Higher accuracy for sensitive systems
- **Euler**: Fast but less accurate

**Precision**: Use `Double` for most cases, `Float` for large-scale simulations
:::

## Working with Coupled Neurons

Neun supports synaptic connections between neurons. Let's create two coupled Hodgkin-Huxley neurons:

```python
import neun_py
import numpy as np
import matplotlib.pyplot as plt

# Create constructor arguments
args = neun_py.HHDoubleConstructorArgs()

# Create two HH neurons
h1 = neun_py.HHDoubleRK4(args)
h2 = neun_py.HHDoubleRK4(args)

# Set parameters for both neurons
for neuron in [h1, h2]:
    neuron.set_param(neun_py.HHDoubleParameter.cm, 1.0 * 7.854e-3)
    neuron.set_param(neun_py.HHDoubleParameter.vna, 50.0)
    neuron.set_param(neun_py.HHDoubleParameter.vk, -77.0)
    neuron.set_param(neun_py.HHDoubleParameter.vl, -54.387)
    neuron.set_param(neun_py.HHDoubleParameter.gna, 120 * 7.854e-3)
    neuron.set_param(neun_py.HHDoubleParameter.gk, 36 * 7.854e-3)
    neuron.set_param(neun_py.HHDoubleParameter.gl, 0.3 * 7.854e-3)

# Set different initial conditions
h1.set_var(neun_py.HHDoubleVariable.v, -75.0)  # Neuron 1 depolarized
h2.set_var(neun_py.HHDoubleVariable.v, -80.0)  # Neuron 2 at rest

# Create electrical synapse connecting the neurons
synapse = neun_py.ESynHHHHDoubleRK4(
    h1, neun_py.HHDoubleVariable.v,  # Source neuron and variable
    h2, neun_py.HHDoubleVariable.v,  # Target neuron and variable
    -0.002, -0.002                    # Conductances (bidirectional)
)

# Simulation
dt = 0.001
T = 100
time = np.arange(0, T, dt)

v1_values = []
v2_values = []
synaptic_currents = []

for t in time:
    # Step synapse first
    synapse.step(dt)
    
    # Add external input to first neuron
    h1.add_synaptic_input(0.1)
    
    # Step both neurons
    h1.step(dt)
    h2.step(dt)
    
    # Record
    v1_values.append(h1.get(neun_py.HHDoubleVariable.v))
    v2_values.append(h2.get(neun_py.HHDoubleVariable.v))
    synaptic_currents.append(synapse.get(neun_py.ESynDoubleVariable.i1))

# Plot results
fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 8))

# Membrane potentials
ax1.plot(time, v1_values, label='Neuron 1', linewidth=1.5, color='blue')
ax1.plot(time, v2_values, label='Neuron 2', linewidth=1.5, color='red')
ax1.set_ylabel('Membrane Potential (mV)')
ax1.set_title('Coupled Hodgkin-Huxley Neurons via Electrical Synapse')
ax1.legend()
ax1.grid(True, alpha=0.3)

# Synaptic current
ax2.plot(time, synaptic_currents, linewidth=1.5, color='purple')
ax2.set_ylabel('Synaptic Current')
ax2.set_xlabel('Time (ms)')
ax2.set_title('Electrical Synaptic Current')
ax2.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()
```

## Input Patterns

Neun supports various input patterns through `add_synaptic_input()`:

### Constant Current

```python
# Applied at each time step
for t in time:
    neuron.add_synaptic_input(2.0)  # Constant 2.0 nA
    neuron.step(dt)
```

### Time-Varying Current

```python
# Step current
for i, t in enumerate(time):
    if 50 <= t < 150:  # Step from 50 to 150 ms
        neuron.add_synaptic_input(3.0)
    else:
        neuron.add_synaptic_input(0.0)
    neuron.step(dt)
```

### Ramp Current

```python
# Linearly increasing current
I_max = 5.0
for i, t in enumerate(time):
    I_current = (I_max * t) / time[-1]
    neuron.add_synaptic_input(I_current)
    neuron.step(dt)
```

### Noisy Current

```python
# Gaussian white noise
I_base = 1.0
sigma = 0.5
for t in time:
    I_noisy = I_base + sigma * np.random.randn()
    neuron.add_synaptic_input(I_noisy)
    neuron.step(dt)
```

### Sinusoidal Current

```python
# Oscillatory input
frequency = 10  # Hz
I_amplitude = 1.0
I_offset = 1.5
for t in time:
    I_sin = I_offset + I_amplitude * np.sin(2 * np.pi * frequency * t / 1000)
    neuron.add_synaptic_input(I_sin)
    neuron.step(dt)
```

### Pulse Train

```python
# Brief current pulses
pulse_times = [50, 100, 150, 200]  # ms
pulse_duration = 5  # ms
pulse_amplitude = 3.0  # nA

for t in time:
    I_pulse = 0.0
    for t_pulse in pulse_times:
        if t_pulse <= t < t_pulse + pulse_duration:
            I_pulse = pulse_amplitude
            break
    neuron.add_synaptic_input(I_pulse)
    neuron.step(dt)
```

## Recording and Analysis

Since neun_py doesn't have a built-in recorder, we manually store the data we need:

```python
import neun_py
import numpy as np
import matplotlib.pyplot as plt

# Create neuron
args = neun_py.HHDoubleConstructorArgs()
neuron = neun_py.HHDoubleRK4(args)

# Set parameters
neuron.set_param(neun_py.HHDoubleParameter.cm, 1.0 * 7.854e-3)
neuron.set_param(neun_py.HHDoubleParameter.vna, 50.0)
neuron.set_param(neun_py.HHDoubleParameter.vk, -77.0)
neuron.set_param(neun_py.HHDoubleParameter.vl, -54.387)
neuron.set_param(neun_py.HHDoubleParameter.gna, 120 * 7.854e-3)
neuron.set_param(neun_py.HHDoubleParameter.gk, 36 * 7.854e-3)
neuron.set_param(neun_py.HHDoubleParameter.gl, 0.3 * 7.854e-3)

# Set initial conditions
neuron.set_var(neun_py.HHDoubleVariable.v, -80.0)
neuron.set_var(neun_py.HHDoubleVariable.m, 0.1)
neuron.set_var(neun_py.HHDoubleVariable.n, 0.7)
neuron.set_var(neun_py.HHDoubleVariable.h, 0.01)

# Simulate and record multiple variables
dt = 0.001
T = 100
time = np.arange(0, T, dt)

# Storage arrays
V = []      # Membrane potential
m_vals = [] # Na activation
h_vals = [] # Na inactivation  
n_vals = [] # K activation

for t in time:
    neuron.add_synaptic_input(0.1)
    neuron.step(dt)
    
    # Record all variables of interest
    V.append(neuron.get(neun_py.HHDoubleVariable.v))
    m_vals.append(neuron.get(neun_py.HHDoubleVariable.m))
    h_vals.append(neuron.get(neun_py.HHDoubleVariable.h))
    n_vals.append(neuron.get(neun_py.HHDoubleVariable.n))

# Plot multiple variables
fig, axes = plt.subplots(4, 1, figsize=(10, 10), sharex=True)

axes[0].plot(time, V, 'b-', linewidth=1.5)
axes[0].set_ylabel('V (mV)')
axes[0].set_title('Membrane Potential')
axes[0].grid(True, alpha=0.3)

axes[1].plot(time, m_vals, 'r-', linewidth=1.5)
axes[1].set_ylabel('m')
axes[1].set_title('Na Activation')
axes[1].grid(True, alpha=0.3)

axes[2].plot(time, h_vals, 'g-', linewidth=1.5)
axes[2].set_ylabel('h')
axes[2].set_title('Na Inactivation')
axes[2].grid(True, alpha=0.3)

axes[3].plot(time, n_vals, 'orange', linewidth=1.5)
axes[3].set_ylabel('n')
axes[3].set_title('K Activation')
axes[3].set_xlabel('Time (ms)')
axes[3].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()
```

## Parameter Exploration

A key use of simulations is exploring parameter space:

```python
import neun_py
import numpy as np
import matplotlib.pyplot as plt

# Explore effect of different sodium conductances
gna_values = np.linspace(80, 160, 10) * 7.854e-3
firing_frequencies = []

dt = 0.001
T = 500  # Longer simulation for frequency estimation
time = np.arange(0, T, dt)

for gna in gna_values:
    # Create neuron
    args = neun_py.HHDoubleConstructorArgs()
    neuron = neun_py.HHDoubleRK4(args)
    
    # Set parameters
    neuron.set_param(neun_py.HHDoubleParameter.cm, 1.0 * 7.854e-3)
    neuron.set_param(neun_py.HHDoubleParameter.vna, 50.0)
    neuron.set_param(neun_py.HHDoubleParameter.vk, -77.0)
    neuron.set_param(neun_py.HHDoubleParameter.vl, -54.387)
    neuron.set_param(neun_py.HHDoubleParameter.gna, gna)  # Vary this
    neuron.set_param(neun_py.HHDoubleParameter.gk, 36 * 7.854e-3)
    neuron.set_param(neun_py.HHDoubleParameter.gl, 0.3 * 7.854e-3)
    
    # Set initial conditions
    neuron.set_var(neun_py.HHDoubleVariable.v, -80.0)
    neuron.set_var(neun_py.HHDoubleVariable.m, 0.1)
    neuron.set_var(neun_py.HHDoubleVariable.n, 0.7)
    neuron.set_var(neun_py.HHDoubleVariable.h, 0.01)
    
    # Simulate and count spikes
    V = []
    spike_count = 0
    for t in time:
        neuron.add_synaptic_input(0.15)
        neuron.step(dt)
        V.append(neuron.get(neun_py.HHDoubleVariable.v))
    
    # Detect spikes (simple threshold crossing)
    V = np.array(V)
    spikes = np.where((V[:-1] < 0) & (V[1:] >= 0))[0]
    
    # Calculate frequency
    if len(spikes) > 1:
        # Use interval between first and last spike
        freq = (len(spikes) - 1) / ((spikes[-1] - spikes[0]) * dt / 1000)
    else:
        freq = 0
    
    firing_frequencies.append(freq)

# Plot parameter sweep
fig, ax = plt.subplots(figsize=(8, 6))
ax.plot(gna_values / 7.854e-3, firing_frequencies, 'o-', linewidth=2, markersize=6)
ax.set_xlabel('Na Conductance (mS/cm²)')
ax.set_ylabel('Firing Frequency (Hz)')
ax.set_title('Effect of Sodium Conductance on Firing Frequency')
ax.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()
```

::: {.callout-tip}
## Parameter Exploration Tips

1. **Start with wide ranges** to understand overall behavior
2. **Refine** around interesting regions
3. **Vary one parameter at a time** initially
4. **Use multiple metrics** (firing rate, CV of ISI, etc.)
5. **Compare with experimental data** when available
:::

## Best Practices

### 1. Organize Your Code

```python
# Good practice: organize simulation code
def create_hh_neuron():
    """Create a Hodgkin-Huxley neuron with standard parameters."""
    args = neun_py.HHDoubleConstructorArgs()
    neuron = neun_py.HHDoubleRK4(args)
    
    # Set standard HH parameters
    neuron.set_param(neun_py.HHDoubleParameter.cm, 1.0 * 7.854e-3)
    neuron.set_param(neun_py.HHDoubleParameter.vna, 50.0)
    neuron.set_param(neun_py.HHDoubleParameter.vk, -77.0)
    neuron.set_param(neun_py.HHDoubleParameter.vl, -54.387)
    neuron.set_param(neun_py.HHDoubleParameter.gna, 120 * 7.854e-3)
    neuron.set_param(neun_py.HHDoubleParameter.gk, 36 * 7.854e-3)
    neuron.set_param(neun_py.HHDoubleParameter.gl, 0.3 * 7.854e-3)
    
    # Set initial conditions
    neuron.set_var(neun_py.HHDoubleVariable.v, -80.0)
    neuron.set_var(neun_py.HHDoubleVariable.m, 0.1)
    neuron.set_var(neun_py.HHDoubleVariable.n, 0.7)
    neuron.set_var(neun_py.HHDoubleVariable.h, 0.01)
    
    return neuron

def run_simulation(neuron, I_ext, dt, T):
    """Run simulation and return time and voltage arrays."""
    time = np.arange(0, T, dt)
    V = []
    
    for t in time:
        neuron.add_synaptic_input(I_ext)
        neuron.step(dt)
        V.append(neuron.get(neun_py.HHDoubleVariable.v))
    
    return time, V

# Use it
neuron = create_hh_neuron()
time, V = run_simulation(neuron, I_ext=0.1, dt=0.001, T=100)
```

### 2. Document Parameters

```python
# Always document what parameters mean and their units
HH_PARAMS = {
    'cm': 1.0 * 7.854e-3,      # Membrane capacitance (μF/cm²)
    'vna': 50.0,               # Na reversal potential (mV)
    'vk': -77.0,               # K reversal potential (mV)
    'vl': -54.387,             # Leak reversal potential (mV)
    'gna': 120 * 7.854e-3,     # Na conductance (mS/cm²)
    'gk': 36 * 7.854e-3,       # K conductance (mS/cm²)
    'gl': 0.3 * 7.854e-3       # Leak conductance (mS/cm²)
}

def set_hh_params(neuron, params):
    """Set HH neuron parameters from a dictionary."""
    neuron.set_param(neun_py.HHDoubleParameter.cm, params['cm'])
    neuron.set_param(neun_py.HHDoubleParameter.vna, params['vna'])
    neuron.set_param(neun_py.HHDoubleParameter.vk, params['vk'])
    neuron.set_param(neun_py.HHDoubleParameter.vl, params['vl'])
    neuron.set_param(neun_py.HHDoubleParameter.gna, params['gna'])
    neuron.set_param(neun_py.HHDoubleParameter.gk, params['gk'])
    neuron.set_param(neun_py.HHDoubleParameter.gl, params['gl'])
```

### 3. Use Meaningful Variable Names

```python
# Good
membrane_voltage = neuron.get(neun_py.HHDoubleVariable.v)
sodium_activation = neuron.get(neun_py.HHDoubleVariable.m)

# Avoid
v = neuron.get(neun_py.HHDoubleVariable.v)
m = neuron.get(neun_py.HHDoubleVariable.m)
```

### 4. Save Important Results

```python
import json

# Save results for later analysis
results = {
    'model': 'HHDoubleRK4',
    'parameters': HH_PARAMS,
    'simulation': {
        'dt': dt,
        'T': T,
        'external_current': 0.1
    },
    'voltage_trace': V,  # List is JSON serializable
    'time': time.tolist()  # Convert numpy array to list
}

with open('hh_simulation_results.json', 'w') as f:
    json.dump(results, f, indent=2)
```

## Common Patterns and Idioms

### Running Multiple Trials

```python
import neun_py
import numpy as np

n_trials = 10
all_voltages = []

dt = 0.001
T = 100
time = np.arange(0, T, dt)

for trial in range(n_trials):
    # Create fresh neuron for each trial
    args = neun_py.HHDoubleConstructorArgs()
    neuron = neun_py.HHDoubleRK4(args)
    
    # Set parameters (use helper function from earlier)
    set_hh_params(neuron, HH_PARAMS)
    
    # Set initial conditions
    neuron.set_var(neun_py.HHDoubleVariable.v, -80.0)
    neuron.set_var(neun_py.HHDoubleVariable.m, 0.1)
    neuron.set_var(neun_py.HHDoubleVariable.n, 0.7)
    neuron.set_var(neun_py.HHDoubleVariable.h, 0.01)
    
    V = []
    for t in time:
        # Add noisy input
        I_noisy = 0.1 + 0.05 * np.random.randn()
        neuron.add_synaptic_input(I_noisy)
        neuron.step(dt)
        V.append(neuron.get(neun_py.HHDoubleVariable.v))
    
    all_voltages.append(V)

# Analyze trial-to-trial variability
all_voltages = np.array(all_voltages)
mean_voltage = np.mean(all_voltages, axis=0)
std_voltage = np.std(all_voltages, axis=0)

print(f"Mean voltage at t=50ms: {mean_voltage[int(50/dt)]:.2f} ± {std_voltage[int(50/dt)]:.2f} mV")
```

### Batch Processing

```python
import neun_py
import numpy as np

# Test multiple parameter combinations
param_grid = {
    'gna': [100, 120, 140],  # mS/cm² (before scaling)
    'gk': [30, 36, 42]       # mS/cm² (before scaling)
}

results = []

dt = 0.001
T = 100
time = np.arange(0, T, dt)

for gna in param_grid['gna']:
    for gk in param_grid['gk']:
        # Create neuron
        args = neun_py.HHDoubleConstructorArgs()
        neuron = neun_py.HHDoubleRK4(args)
        
        # Set parameters with varied conductances
        neuron.set_param(neun_py.HHDoubleParameter.cm, 1.0 * 7.854e-3)
        neuron.set_param(neun_py.HHDoubleParameter.vna, 50.0)
        neuron.set_param(neun_py.HHDoubleParameter.vk, -77.0)
        neuron.set_param(neun_py.HHDoubleParameter.vl, -54.387)
        neuron.set_param(neun_py.HHDoubleParameter.gna, gna * 7.854e-3)
        neuron.set_param(neun_py.HHDoubleParameter.gk, gk * 7.854e-3)
        neuron.set_param(neun_py.HHDoubleParameter.gl, 0.3 * 7.854e-3)
        
        # Set initial conditions
        neuron.set_var(neun_py.HHDoubleVariable.v, -80.0)
        neuron.set_var(neun_py.HHDoubleVariable.m, 0.1)
        neuron.set_var(neun_py.HHDoubleVariable.n, 0.7)
        neuron.set_var(neun_py.HHDoubleVariable.h, 0.01)
        
        # Simulate
        V = []
        for t in time:
            neuron.add_synaptic_input(0.1)
            neuron.step(dt)
            V.append(neuron.get(neun_py.HHDoubleVariable.v))
        
        # Detect spikes
        V_array = np.array(V)
        n_spikes = np.sum((V_array[:-1] < 0) & (V_array[1:] >= 0))
        
        results.append({
            'gna': gna,
            'gk': gk,
            'n_spikes': n_spikes,
            'mean_voltage': np.mean(V)
        })

# Analyze results
import pandas as pd
df = pd.DataFrame(results)
print(df)
```

## Summary

In this section, we've learned:

- ✅ How to install Neun C++ library and neun_py Python bindings
- ✅ Basic architecture: neurons, synapses, integrators, parameters/variables
- ✅ Creating and simulating Hodgkin-Huxley neurons with neun_py
- ✅ Manual recording and analyzing results
- ✅ Parameter exploration and sweeps
- ✅ Best practices for simulation code

::: {.callout-note}
## Key Takeaways

1. **Neun workflow**: Create args → Instantiate model → Set params → Set vars → Simulate → Record
2. **Type safety**: Use enums for parameters and variables (e.g., `HHDoubleParameter.cm`)
3. **Model naming**: `{Model}{Precision}{Integrator}` (e.g., `HHDoubleRK4`)
4. **Synapses**: Named as `{Type}{Neuron1}{Neuron2}{Precision}{Integrator}`
5. **Organization**: Write helper functions for creating and configuring neurons
:::

## Exercises

Try these exercises to solidify your understanding:

1. **Parameter Sweep**: Create a 2D parameter sweep varying both `gna` and `gk` in the HH model
2. **Integrator Comparison**: Compare RK4 vs RK6 integrators for the same HH neuron
3. **Phase Plane**: Plot the (V, n) phase plane for the HH model
4. **Coupling Strength**: Explore how synapse conductance affects synchronization between two HR neurons
5. **Noise Effects**: Compare firing patterns with different noise levels in the input current

## Next Steps

Now that you're familiar with Neun basics, we'll move on to:

- Simulating synaptic dynamics
- Creating connected networks
- Analyzing network behavior

---

**Continue to [Part 3: Single Neuron Modeling](03-single-neurons.qmd)**
